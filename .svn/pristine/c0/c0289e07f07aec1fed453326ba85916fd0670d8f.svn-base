'use client';

import { useState, useEffect, useRef, use, useCallback } from 'react';
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { ScrollArea } from '@/components/ui/scroll-area';
import { ChatMessageBubble } from '@/components/chat/ChatMessage';
import { VoiceRecorder } from '@/components/chat/VoiceRecorder';
import { useChatStore, type ChatMessage as ChatMessageType } from '@/stores/chatStore';
import { useSettingsStore } from '@/stores/settingsStore';
import { ttsManager } from '@/lib/tts/manager';

interface ChatPageProps {
  params: Promise<{ id: string }>;
}

export default function ChatPage({ params }: ChatPageProps) {
  const { id: chatId } = use(params);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const [isSending, setIsSending] = useState(false);
  const [ttsInitialized, setTtsInitialized] = useState(false);
  const [ttsError, setTtsError] = useState<string | null>(null);
  // CURSOR: Store TTS init promise to await it when needed for first message
  const ttsInitPromiseRef = useRef<Promise<boolean> | null>(null);
  
  // CURSOR: Use selectors for better performance - only re-render when specific state changes
  const currentChat = useChatStore((state) => state.currentChat);
  const messages = useChatStore((state) => state.messages);
  const currentlyPlayingId = useChatStore((state) => state.currentlyPlayingId);
  const isLoading = useChatStore((state) => state.isLoading);
  
  // Actions don't cause re-renders, safe to get from store directly
  const setCurrentChat = useChatStore((state) => state.setCurrentChat);
  const setMessages = useChatStore((state) => state.setMessages);
  const addMessage = useChatStore((state) => state.addMessage);
  const updateMessage = useChatStore((state) => state.updateMessage);
  const setCurrentlyPlaying = useChatStore((state) => state.setCurrentlyPlaying);
  const setLoading = useChatStore((state) => state.setLoading);

  // CURSOR: Use selectors for settings too
  const tts = useSettingsStore((state) => state.tts);
  const ui = useSettingsStore((state) => state.ui);

  // Initialize TTS
  useEffect(() => {
    const initTTS = async (): Promise<boolean> => {
      try {
        await ttsManager.initialize(tts.provider);
        ttsManager.setVoice(tts.voice);
        ttsManager.setSpeed(tts.speed);
        setTtsInitialized(true);
        setTtsError(null);
        return true;
      } catch (error) {
        console.error('Failed to initialize TTS:', error);
        setTtsError(error instanceof Error ? error.message : 'TTS initialization failed');
        setTtsInitialized(false);
        return false;
      }
    };
    ttsInitPromiseRef.current = initTTS();
  }, [tts.provider, tts.voice, tts.speed]);

  // CURSOR: Track which message IDs we've already played to prevent double-play
  const playedMessageIds = useRef<Set<string>>(new Set());

  // Fetch chat and messages
  useEffect(() => {
    const fetchChat = async () => {
      setLoading(true);
      try {
        const response = await fetch(`/api/chat?id=${chatId}`);
        const data = await response.json();
        
        if (data.chat) {
          // CURSOR: Convert date strings to Date objects from API response
          setCurrentChat({
            ...data.chat,
            createdAt: new Date(data.chat.createdAt),
            updatedAt: new Date(data.chat.updatedAt),
          });
          
          // CURSOR: Check if this is a new chat (only 1 assistant message = opening message)
          const isNewChat = data.messages.length === 1 && 
                           data.messages[0].role === 'assistant';
          
          if (isNewChat) {
            // Mark first message as needing playback
            setMessages(data.messages.map((msg: ChatMessageType) => ({
              ...msg,
              createdAt: new Date(msg.createdAt),
              state: 'audio_loading',
              audioPlayed: false,
            })));
          } else {
            // Existing chat - all messages already played
            setMessages(data.messages.map((msg: ChatMessageType) => ({
              ...msg,
              createdAt: new Date(msg.createdAt),
              state: 'revealed',
              audioPlayed: true,
            })));
          }
        }
      } catch (error) {
        console.error('Failed to fetch chat:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchChat();
  }, [chatId, setCurrentChat, setMessages, setLoading]);

  // CURSOR: Play first message for new chats once TTS is ready
  useEffect(() => {
    if (messages.length === 0) return;
    
    const firstMessage = messages[0];
    
    // Only play if: assistant message, in audio_loading state, and not already played
    if (firstMessage.role !== 'assistant' || 
        firstMessage.state !== 'audio_loading' ||
        playedMessageIds.current.has(firstMessage.id)) {
      return;
    }
    
    // Mark as played BEFORE async work to prevent double-play
    playedMessageIds.current.add(firstMessage.id);
    
    const playFirstMessage = async () => {
      if (ui.listenFirstMode) {
        // Wait for TTS init to complete
        const ttsReady = ttsInitPromiseRef.current 
          ? await ttsInitPromiseRef.current 
          : false;
        
        if (ttsReady) {
          try {
            const audio = await ttsManager.createAudioElement(firstMessage.content);
            const audioUrl = audio.src;
            
            updateMessage(firstMessage.id, { state: 'playing', audioUrl });
            setCurrentlyPlaying(firstMessage.id);
            
            audio.onended = () => {
              updateMessage(firstMessage.id, { state: 'revealed', audioPlayed: true });
              setCurrentlyPlaying(null);
            };
            
            audio.onerror = () => {
              updateMessage(firstMessage.id, { state: 'revealed', audioPlayed: true });
              setCurrentlyPlaying(null);
            };
            
            await audio.play();
          } catch (err) {
            console.error('First message TTS failed:', err);
            updateMessage(firstMessage.id, { state: 'revealed', audioPlayed: true });
          }
        } else {
          // TTS not available, just reveal
          updateMessage(firstMessage.id, { state: 'revealed', audioPlayed: true });
        }
      } else {
        // Listen-first mode disabled, just reveal
        updateMessage(firstMessage.id, { state: 'revealed', audioPlayed: true });
      }
    };
    
    playFirstMessage();
  }, [messages, ui.listenFirstMode, updateMessage, setCurrentlyPlaying]);

  // Scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // CURSOR: Play audio for a message. ttsReady param allows bypassing state check
  // when we've already awaited the TTS init promise
  const playMessageAudio = async (
    messageId: string, 
    content: string, 
    ttsReady?: boolean
  ) => {
    const isTtsAvailable = ttsReady ?? ttsInitialized;
    if (!isTtsAvailable || !content) {
      // If TTS not available, just reveal the message
      updateMessage(messageId, { state: 'revealed', audioPlayed: true });
      return;
    }

    try {
      updateMessage(messageId, { state: 'audio_loading' });
      
      const audio = await ttsManager.createAudioElement(content);
      const audioUrl = audio.src;
      
      updateMessage(messageId, { 
        state: 'playing',
        audioUrl,
      });
      setCurrentlyPlaying(messageId);

      audio.onended = () => {
        updateMessage(messageId, { 
          state: 'revealed',
          audioPlayed: true,
        });
        setCurrentlyPlaying(null);
      };

      audio.onerror = () => {
        console.error('Audio playback failed');
        updateMessage(messageId, { state: 'revealed', audioPlayed: true });
        setCurrentlyPlaying(null);
      };

      await audio.play();
    } catch (err) {
      console.error('TTS failed:', err);
      updateMessage(messageId, { state: 'revealed', audioPlayed: true });
      setCurrentlyPlaying(null);
    }
  };

  // Handle sending message
  const sendMessage = async (text: string) => {
    if (!text.trim() || isSending) return;

    setIsSending(true);

    // Add user message immediately
    const tempUserMessageId = `temp-user-${Date.now()}`;
    const tempUserMessage: ChatMessageType = {
      id: tempUserMessageId,
      chatId,
      role: 'user',
      content: text,
      state: 'revealed',
      audioPlayed: true,
      createdAt: new Date(),
    };
    addMessage(tempUserMessage);

    // Add placeholder for AI response
    const tempAiMessageId = `temp-ai-${Date.now()}`;
    addMessage({
      id: tempAiMessageId,
      chatId,
      role: 'assistant',
      content: '',
      state: 'generating',
      audioPlayed: false,
      createdAt: new Date(),
    });

    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'message',
          chatId,
          content: text,
        }),
      });

      const data = await response.json();

      if (data.aiMessage) {
        const realAiMessageId = data.aiMessage.id;
        
        // Update user message with real ID
        if (data.userMessage) {
          updateMessage(tempUserMessageId, {
            id: data.userMessage.id,
          });
        }

        // CURSOR: Update AI message with real ID and content BEFORE audio playback
        // to avoid race condition where onended callback references old temp ID
        updateMessage(tempAiMessageId, {
          id: realAiMessageId,
          content: data.aiMessage.content,
          createdAt: new Date(data.aiMessage.createdAt),
        });

        // Play audio if listen-first mode is enabled
        if (ui.listenFirstMode) {
          // CURSOR: Show audio loading state while waiting for TTS init
          updateMessage(realAiMessageId, { state: 'audio_loading' });
          
          // CURSOR: Wait for TTS initialization to complete before deciding
          // This ensures first message also plays audio once TTS is ready
          const ttsReady = ttsInitPromiseRef.current 
            ? await ttsInitPromiseRef.current 
            : false;
          
          if (ttsReady) {
            await playMessageAudio(realAiMessageId, data.aiMessage.content, true);
          } else {
            // TTS failed to initialize, reveal the message
            updateMessage(realAiMessageId, { 
              state: 'revealed', 
              audioPlayed: true 
            });
          }
        } else {
          // Listen-first mode disabled, just reveal the message
          updateMessage(realAiMessageId, { 
            state: 'revealed', 
            audioPlayed: true 
          });
        }
      }
    } catch (error) {
      console.error('Failed to send message:', error);
      updateMessage(tempAiMessageId, {
        content: 'Sorry, there was an error. Please try again.',
        state: 'revealed',
      });
    } finally {
      setIsSending(false);
    }
  };

  // CURSOR: Handle voice recording - called when recording stops with transcript
  const handleVoiceSend = useCallback((text: string) => {
    if (text.trim() && !isSending) {
      sendMessage(text);
    }
  }, [isSending]);

  // CURSOR: Get mother language from settings
  const language = useSettingsStore((state) => state.language);

  // Handle analyze request
  const handleAnalyze = async (messageId: string) => {
    try {
      const response = await fetch('/api/analyze', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          chatId,
          messageId,
          motherLanguage: language.mother, // CURSOR: Pass mother language for explanations
        }),
      });

      const data = await response.json();
      if (data.analysis) {
        updateMessage(messageId, { analysis: data.analysis });
      }
    } catch (error) {
      console.error('Analysis failed:', error);
    }
  };

  // CURSOR: Handle replay - regenerate audio and play
  const handleReplay = useCallback(async (messageId: string, content: string) => {
    if (currentlyPlayingId) return; // Already playing something
    
    // Check if TTS is available
    const ttsReady = ttsInitPromiseRef.current 
      ? await ttsInitPromiseRef.current 
      : ttsInitialized;
    
    if (!ttsReady || !content) return;
    
    try {
      setCurrentlyPlaying(messageId);
      
      const audio = await ttsManager.createAudioElement(content);
      
      audio.onended = () => {
        setCurrentlyPlaying(null);
      };
      
      audio.onerror = () => {
        setCurrentlyPlaying(null);
      };
      
      await audio.play();
    } catch (err) {
      console.error('Replay failed:', err);
      setCurrentlyPlaying(null);
    }
  }, [currentlyPlayingId, ttsInitialized, setCurrentlyPlaying]);

  return (
    <div className="flex flex-col h-screen gradient-bg">
      {/* Header */}
      <header className="border-b bg-background/80 backdrop-blur-sm sticky top-0 z-10">
        <div className="container mx-auto px-4 py-3 flex items-center gap-4">
          <Link href="/">
            <Button variant="ghost" size="icon">
              <ArrowLeftIcon className="h-5 w-5" />
            </Button>
          </Link>
          <div className="flex-1">
            <h1 className="font-semibold line-clamp-1">
              {currentChat?.title || 'Conversation'}
            </h1>
            <p className="text-xs text-muted-foreground">
              {currentChat?.topicType === 'general' ? 'üí¨ Free conversation' : 
               currentChat?.topicType === 'roleplay' ? 'üé≠ Roleplay' : 
               'üìö Topic discussion'}
            </p>
          </div>
          {ttsError && (
            <span className="text-xs text-amber-500">‚ö†Ô∏è TTS unavailable</span>
          )}
        </div>
      </header>

      {/* Messages */}
      <ScrollArea className="flex-1 p-4">
        <div className="container mx-auto max-w-2xl space-y-4">
          {isLoading ? (
            <div className="flex items-center justify-center py-8">
              <div className="animate-spin h-8 w-8 border-2 border-primary border-t-transparent rounded-full" />
            </div>
          ) : messages.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              Start the conversation...
            </div>
          ) : (
            messages.map((message) => (
              <ChatMessageBubble
                key={message.id}
                message={message}
                isPlaying={currentlyPlayingId === message.id}
                onReplay={() => handleReplay(message.id, message.content)}
                onAnalyze={() => handleAnalyze(message.id)}
                className={message.role === 'user' ? 'animate-slide-in-right' : 'animate-slide-in-left'}
              />
            ))
          )}
          <div ref={messagesEndRef} />
        </div>
      </ScrollArea>

      {/* Input area - Voice only */}
      <div className="border-t bg-background/80 backdrop-blur-sm p-4">
        <div className="container mx-auto max-w-2xl">
          <VoiceRecorder
            onSend={handleVoiceSend}
            disabled={isSending}
            language={currentChat?.language || 'en'}
            dialect={currentChat?.dialect || 'american'}
          />
        </div>
      </div>
    </div>
  );
}

// Icons
function ArrowLeftIcon({ className }: { className?: string }) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
      <line x1="19" y1="12" x2="5" y2="12" />
      <polyline points="12 19 5 12 12 5" />
    </svg>
  );
}

