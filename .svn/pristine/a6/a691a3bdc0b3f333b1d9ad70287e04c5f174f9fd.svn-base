import { NextRequest, NextResponse } from 'next/server';
import { getChat, getChatMessages } from '@/lib/db/queries';
import { aiManager } from '@/lib/ai/manager';
import { contextManager } from '@/lib/ai/context';
import { buildSystemPrompt, getSuggestionPrompt } from '@/lib/ai/prompts';

// CURSOR: Track last initialized provider to reinitialize when changed
let lastInitializedProvider: string | null = null;

// CURSOR: Initialize with specified provider and model, or use defaults
async function ensureInitialized(providerId?: string, model?: string) {
  const targetProvider = providerId || 'openai-chat';
  
  if (lastInitializedProvider !== targetProvider) {
    await aiManager.initialize(targetProvider);
    lastInitializedProvider = targetProvider;
  }
  
  if (model) {
    aiManager.setModel(model);
  }
}

// POST /api/suggest - Generate reply suggestions for the learner
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { chatId, count = 3, aiProvider, aiModel } = body;
    
    // CURSOR: Initialize with provider/model from request (from user settings)
    await ensureInitialized(aiProvider, aiModel);
    
    if (!chatId) {
      return NextResponse.json({ error: 'Chat ID required' }, { status: 400 });
    }
    
    const chat = await getChat(chatId);
    if (!chat) {
      return NextResponse.json({ error: 'Chat not found' }, { status: 404 });
    }
    
    // CURSOR: Get recent messages for context
    const messages = await getChatMessages(chatId);
    
    // CURSOR: Build context with the conversation history
    let topicDetails: Record<string, unknown> = {};
    try {
      topicDetails = chat.topicDetails ? JSON.parse(chat.topicDetails) : {};
    } catch {
      console.warn('Failed to parse topicDetails for chat:', chatId);
    }
    
    // CURSOR: Get learning language from chat
    const learningLanguage = chat.language || 'en';
    
    const systemPrompt = buildSystemPrompt(
      chat.topicType as 'general' | 'roleplay' | 'topic',
      topicDetails.topicKey as string | undefined,
      undefined,
      learningLanguage
    );
    
    const context = await contextManager.buildContext(chatId, systemPrompt, chat.threadId || undefined);
    
    // CURSOR: Get the suggestion prompt with learning language
    const suggestionPrompt = getSuggestionPrompt(count, learningLanguage);
    
    // CURSOR: Build a prompt that includes recent conversation for context
    const recentMessages = messages.slice(-6).map(m => 
      `${m.role === 'user' ? 'Learner' : 'Tutor'}: ${m.content}`
    ).join('\n');
    
    const fullPrompt = `${suggestionPrompt}\n\nRecent conversation:\n${recentMessages}\n\nGenerate ${count} natural reply suggestions for the learner:`;
    
    const response = await aiManager.generate(context, fullPrompt);
    
    // CURSOR: Parse JSON response
    try {
      const jsonMatch = response.content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        return NextResponse.json({ 
          suggestions: parsed.suggestions || [],
        });
      }
    } catch (parseError) {
      console.error('Failed to parse suggestion response:', parseError);
    }
    
    return NextResponse.json({ 
      error: 'Failed to generate suggestions',
      raw: response.content,
    }, { status: 500 });
    
  } catch (error) {
    console.error('Suggest API error:', error);
    return NextResponse.json(
      { error: 'Failed to generate suggestions' },
      { status: 500 }
    );
  }
}
