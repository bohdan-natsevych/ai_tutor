// DeepL Translation Client

export interface TranslationResult {
  sourceText: string;
  translatedText: string;
  sourceLanguage: string;
  targetLanguage: string;
  detectedSourceLang?: string;
}

export interface DeepLTranslation {
  detected_source_language: string;
  text: string;
}

export interface DeepLResponse {
  translations: DeepLTranslation[];
}

// Language code mapping
const LANGUAGE_CODES: Record<string, string> = {
  en: 'EN',
  uk: 'UK', // Ukrainian
  de: 'DE',
  fr: 'FR',
  es: 'ES',
  it: 'IT',
  nl: 'NL',
  pl: 'PL',
  pt: 'PT-PT',
  ru: 'RU',
  ja: 'JA',
  zh: 'ZH',
  ko: 'KO',
};

class DeepLClient {
  private apiKey: string | null = null;
  private baseUrl = 'https://api-free.deepl.com/v2'; // Free tier URL

  initialize(apiKey?: string): void {
    this.apiKey = apiKey || process.env.DEEPL_API_KEY || null;
    
    // Check if using paid tier
    if (this.apiKey && !this.apiKey.endsWith(':fx')) {
      this.baseUrl = 'https://api.deepl.com/v2';
    }
  }

  isAvailable(): boolean {
    return !!this.apiKey;
  }

  async translate(
    text: string,
    targetLanguage: string,
    sourceLanguage?: string
  ): Promise<TranslationResult> {
    if (!this.apiKey) {
      throw new Error('DeepL API key not configured');
    }

    const targetLang = LANGUAGE_CODES[targetLanguage] || targetLanguage.toUpperCase();
    const sourceLang = sourceLanguage 
      ? LANGUAGE_CODES[sourceLanguage] || sourceLanguage.toUpperCase()
      : undefined;

    const params = new URLSearchParams({
      text,
      target_lang: targetLang,
    });

    if (sourceLang) {
      params.append('source_lang', sourceLang);
    }

    const response = await fetch(`${this.baseUrl}/translate`, {
      method: 'POST',
      headers: {
        'Authorization': `DeepL-Auth-Key ${this.apiKey}`,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: params.toString(),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`DeepL API error: ${response.status} - ${errorText}`);
    }

    const data: DeepLResponse = await response.json();
    const translation = data.translations[0];

    return {
      sourceText: text,
      translatedText: translation.text,
      sourceLanguage: sourceLanguage || translation.detected_source_language.toLowerCase(),
      targetLanguage,
      detectedSourceLang: translation.detected_source_language.toLowerCase(),
    };
  }

  // Translate multiple texts at once
  async translateBatch(
    texts: string[],
    targetLanguage: string,
    sourceLanguage?: string
  ): Promise<TranslationResult[]> {
    if (!this.apiKey) {
      throw new Error('DeepL API key not configured');
    }

    const targetLang = LANGUAGE_CODES[targetLanguage] || targetLanguage.toUpperCase();
    const sourceLang = sourceLanguage 
      ? LANGUAGE_CODES[sourceLanguage] || sourceLanguage.toUpperCase()
      : undefined;

    const params = new URLSearchParams();
    texts.forEach(text => params.append('text', text));
    params.append('target_lang', targetLang);
    
    if (sourceLang) {
      params.append('source_lang', sourceLang);
    }

    const response = await fetch(`${this.baseUrl}/translate`, {
      method: 'POST',
      headers: {
        'Authorization': `DeepL-Auth-Key ${this.apiKey}`,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: params.toString(),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`DeepL API error: ${response.status} - ${errorText}`);
    }

    const data: DeepLResponse = await response.json();

    return data.translations.map((translation, index) => ({
      sourceText: texts[index],
      translatedText: translation.text,
      sourceLanguage: sourceLanguage || translation.detected_source_language.toLowerCase(),
      targetLanguage,
      detectedSourceLang: translation.detected_source_language.toLowerCase(),
    }));
  }

  // Get supported languages
  async getSupportedLanguages(type: 'source' | 'target' = 'target'): Promise<Array<{ language: string; name: string }>> {
    if (!this.apiKey) {
      throw new Error('DeepL API key not configured');
    }

    const response = await fetch(`${this.baseUrl}/languages?type=${type}`, {
      headers: {
        'Authorization': `DeepL-Auth-Key ${this.apiKey}`,
      },
    });

    if (!response.ok) {
      throw new Error(`DeepL API error: ${response.status}`);
    }

    return response.json();
  }

  // Check usage
  async getUsage(): Promise<{ character_count: number; character_limit: number }> {
    if (!this.apiKey) {
      throw new Error('DeepL API key not configured');
    }

    const response = await fetch(`${this.baseUrl}/usage`, {
      headers: {
        'Authorization': `DeepL-Auth-Key ${this.apiKey}`,
      },
    });

    if (!response.ok) {
      throw new Error(`DeepL API error: ${response.status}`);
    }

    return response.json();
  }
}

// Export singleton instance
export const deeplClient = new DeepLClient();

// Initialize on import if API key is available
if (process.env.DEEPL_API_KEY) {
  deeplClient.initialize();
}
