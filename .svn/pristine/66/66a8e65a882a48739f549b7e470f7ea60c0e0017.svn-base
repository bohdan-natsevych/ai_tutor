'use client';

import { useState, useCallback, useMemo } from 'react';
import { TranslationPopup } from './TranslationPopup';

// CURSOR: SelectableText - Allows users to select words/phrases for translation
// Wraps message content and handles text selection
// Also supports word highlighting during TTS playback

interface SelectableTextProps {
  text: string;
  chatId?: string;
  className?: string;
  highlightedWordIndex?: number; // CURSOR: Index of word to highlight during TTS playback (-1 = none)
}

export function SelectableText({ text, chatId, className = '', highlightedWordIndex = -1 }: SelectableTextProps) {
  const [selectedText, setSelectedText] = useState<string | null>(null);
  const [popoverPosition, setPopoverPosition] = useState<{ x: number; y: number } | null>(null);

  // CURSOR: Parse text into tokens (words and whitespace/punctuation) for highlighting
  // We preserve whitespace and punctuation to maintain original formatting
  const tokens = useMemo(() => {
    return parseTextIntoTokens(text);
  }, [text]);

  const handleMouseUp = useCallback(() => {
    const selection = window.getSelection();
    const selected = selection?.toString().trim();
    
    if (selected && selected.length > 0 && selected.length < 200) {
      setSelectedText(selected);
      
      // Get selection position for popover
      const range = selection?.getRangeAt(0);
      if (range) {
        const rect = range.getBoundingClientRect();
        setPopoverPosition({
          x: rect.left + rect.width / 2,
          y: rect.top,
        });
      }
    } else {
      setSelectedText(null);
      setPopoverPosition(null);
    }
  }, []);

  const handleClick = useCallback(() => {
    // Clear selection on click elsewhere
    setTimeout(() => {
      const selection = window.getSelection();
      if (!selection?.toString().trim()) {
        setSelectedText(null);
        setPopoverPosition(null);
      }
    }, 100);
  }, []);

  // CURSOR: Render text with word highlighting for TTS playback
  const renderHighlightedText = () => {
    if (highlightedWordIndex < 0) {
      // No highlighting, render plain text
      return text;
    }

    let wordCount = 0;
    return tokens.map((token, index) => {
      if (token.isWord) {
        const isHighlighted = wordCount === highlightedWordIndex;
        wordCount++;
        return (
          <span
            key={index}
            className={isHighlighted ? 'bg-yellow-300 dark:bg-yellow-600 rounded px-0.5 transition-colors duration-150' : ''}
          >
            {token.text}
          </span>
        );
      }
      // Whitespace/punctuation - render as-is
      return <span key={index}>{token.text}</span>;
    });
  };

  return (
    <div className={`relative ${className}`}>
      <p 
        className="whitespace-pre-wrap cursor-text select-text"
        onMouseUp={handleMouseUp}
        onClick={handleClick}
      >
        {renderHighlightedText()}
      </p>
      
      {/* Translation popup for selected text */}
      {selectedText && popoverPosition && (
        <div 
          className="fixed z-50"
          style={{ 
            left: popoverPosition.x, 
            top: popoverPosition.y - 10,
            transform: 'translate(-50%, -100%)',
          }}
        >
          <TranslationPopup 
            text={selectedText} 
            chatId={chatId}
            onSaveToVocabulary={() => {
              setSelectedText(null);
              setPopoverPosition(null);
            }}
          >
            <button className="px-3 py-1.5 bg-primary text-primary-foreground rounded-lg shadow-lg text-sm font-medium hover:bg-primary/90 transition-colors">
              Translate
            </button>
          </TranslationPopup>
        </div>
      )}
    </div>
  );
}

// CURSOR: Token type for text parsing
interface TextToken {
  text: string;
  isWord: boolean;
}

// CURSOR: Parse text into tokens (words vs whitespace/punctuation)
// This allows us to highlight individual words while preserving formatting
function parseTextIntoTokens(text: string): TextToken[] {
  const tokens: TextToken[] = [];
  // Match sequences of word characters OR sequences of non-word characters
  const regex = /(\S+)|(\s+)/g;
  let match;
  
  while ((match = regex.exec(text)) !== null) {
    if (match[1]) {
      // Non-whitespace token - could be word or punctuation
      tokens.push({ text: match[1], isWord: true });
    } else if (match[2]) {
      // Whitespace token
      tokens.push({ text: match[2], isWord: false });
    }
  }
  
  return tokens;
}

// CURSOR: Utility function to count words in text (exported for use in timing calculation)
export function countWords(text: string): number {
  const tokens = parseTextIntoTokens(text);
  return tokens.filter(t => t.isWord).length;
}
