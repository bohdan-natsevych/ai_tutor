import { NextRequest, NextResponse } from 'next/server';
import { createChat, getChat, getAllChats, updateChat, deleteChat, createMessage, getChatMessages } from '@/lib/db/queries';
import { aiManager } from '@/lib/ai/manager';
import { contextManager } from '@/lib/ai/context';
import { buildSystemPrompt } from '@/lib/ai/prompts';

// CURSOR: Track last initialized provider to reinitialize when changed
let lastInitializedProvider: string | null = null;

// CURSOR: Initialize with specified provider and model, or use defaults
async function ensureInitialized(providerId?: string, model?: string) {
  const targetProvider = providerId || 'openai-chat';
  
  // CURSOR: Reinitialize if provider changed
  if (lastInitializedProvider !== targetProvider) {
    await aiManager.initialize(targetProvider);
    lastInitializedProvider = targetProvider;
  }
  
  // CURSOR: Set model if provided
  if (model) {
    aiManager.setModel(model);
  }
}

// GET /api/chat - List all chats
// GET /api/chat?id=xxx - Get specific chat with messages
export async function GET(request: NextRequest) {
  // CURSOR: GET doesn't need AI, but ensure basic initialization
  await ensureInitialized();
  try {
    const searchParams = request.nextUrl.searchParams;
    const chatId = searchParams.get('id');

    if (chatId) {
      const chat = await getChat(chatId);
      if (!chat) {
        return NextResponse.json({ error: 'Chat not found' }, { status: 404 });
      }
      
      const messages = await getChatMessages(chatId);
      return NextResponse.json({ chat, messages });
    }

    const chats = await getAllChats();
    return NextResponse.json({ chats });
  } catch (error) {
    console.error('Chat GET error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch chats' },
      { status: 500 }
    );
  }
}

// POST /api/chat - Create new chat or send message
export async function POST(request: NextRequest) {
  try {
    const contentType = request.headers.get('content-type') || '';
    const isFormData = contentType.includes('multipart/form-data');
    let body: Record<string, unknown> = {};
    let audioBuffer: Buffer | null = null;
    let audioFormat: string | null = null;

    if (isFormData) {
      const formData = await request.formData();
      body = Object.fromEntries(formData.entries());
      const audioFile = formData.get('audio');
      if (audioFile && typeof audioFile === 'object' && 'arrayBuffer' in audioFile) {
        const arrayBuffer = await (audioFile as File).arrayBuffer();
        audioBuffer = Buffer.from(arrayBuffer);
      }
      const audioFormatValue = formData.get('audioFormat');
      if (typeof audioFormatValue === 'string') {
        audioFormat = audioFormatValue;
      }
    } else {
      body = await request.json();
    }

    const { action, aiProvider, aiModel } = body as { action?: string; aiProvider?: string; aiModel?: string };
    
    // CURSOR: Initialize with provider/model from request (from user settings)
    await ensureInitialized(aiProvider, aiModel);

    if (action === 'create') {
      // Create new chat
      const { title, topicType, topicKey, language, dialect, aiMode } = body;
      
      const chat = await createChat({
        title: title || 'New Conversation',
        topicType: topicType || 'general',
        topicDetails: topicKey ? JSON.stringify({ topicKey }) : undefined,
        language: language || 'en',
        dialect: dialect || 'american',
        aiProvider: aiProvider || 'openai-chat',
        aiMode: aiMode || 'chat',
      });

      // Generate opening message from AI
      const systemPrompt = buildSystemPrompt(topicType || 'general', topicKey, undefined, language || 'en');
      const context = await contextManager.buildContext(chat.id, systemPrompt);
      
      const openingPrompt = topicType === 'roleplay'
        ? 'Start the roleplay scenario with an appropriate opening.'
        : topicType === 'topic'
        ? 'Start a conversation about the given topic.'
        : 'Greet the learner warmly and ask how they are doing today.';
      
      const response = await aiManager.chat(context, openingPrompt);
      
      // Save the AI's opening message
      const aiMessage = await createMessage({
        chatId: chat.id,
        role: 'assistant',
        content: response.content,
      });

      return NextResponse.json({ 
        chat, 
        openingMessage: {
          ...aiMessage,
          state: 'audio_loading',
          audioPlayed: false,
        }
      });
    }

    if (action === 'message') {
      // Send message to existing chat
      const { chatId, content } = body as { chatId?: string; content?: string };
      if (!chatId || !content) {
        return NextResponse.json({ error: 'chatId and content required' }, { status: 400 });
      }
      
      const chat = await getChat(chatId);
      if (!chat) {
        return NextResponse.json({ error: 'Chat not found' }, { status: 404 });
      }

      // Save user message
      const userMessage = await createMessage({
        chatId,
        role: 'user',
        content,
        audioBlob: audioBuffer || undefined,
        audioFormat: audioFormat || undefined,
      });

      // CURSOR: Build context and get AI response with safe JSON parsing
      let topicDetails: Record<string, unknown> = {};
      try {
        topicDetails = chat.topicDetails ? JSON.parse(chat.topicDetails) : {};
      } catch {
        console.warn('Failed to parse topicDetails for chat:', chatId);
      }
      const systemPrompt = buildSystemPrompt(
        chat.topicType as 'general' | 'roleplay' | 'topic',
        topicDetails.topicKey,
        undefined,
        chat.language || 'en'
      );
      
      const context = await contextManager.buildContext(chatId, systemPrompt, chat.threadId || undefined);
      const response = await aiManager.chat(context, content);

      // Save AI response
      const aiMessage = await createMessage({
        chatId,
        role: 'assistant',
        content: response.content,
      });

      return NextResponse.json({
        userMessage: {
          ...userMessage,
          state: 'revealed',
          audioPlayed: true,
        },
        aiMessage: {
          ...aiMessage,
          state: 'audio_loading',
          audioPlayed: false,
        },
        usage: response.usage,
      });
    }

    return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
  } catch (error) {
    console.error('Chat POST error:', error);
    return NextResponse.json(
      { error: 'Failed to process chat request' },
      { status: 500 }
    );
  }
}

// PATCH /api/chat - Update chat
export async function PATCH(request: NextRequest) {
  // CURSOR: PATCH doesn't need AI, but ensure basic initialization
  await ensureInitialized();
  try {
    const body = await request.json();
    const { chatId, ...updates } = body;

    if (!chatId) {
      return NextResponse.json({ error: 'Chat ID required' }, { status: 400 });
    }

    await updateChat(chatId, updates);
    const chat = await getChat(chatId);
    
    return NextResponse.json({ chat });
  } catch (error) {
    console.error('Chat PATCH error:', error);
    return NextResponse.json(
      { error: 'Failed to update chat' },
      { status: 500 }
    );
  }
}

// DELETE /api/chat?id=xxx - Delete chat
export async function DELETE(request: NextRequest) {
  await ensureInitialized();
  try {
    const searchParams = request.nextUrl.searchParams;
    const chatId = searchParams.get('id');

    if (!chatId) {
      return NextResponse.json({ error: 'Chat ID required' }, { status: 400 });
    }

    await deleteChat(chatId);
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Chat DELETE error:', error);
    return NextResponse.json(
      { error: 'Failed to delete chat' },
      { status: 500 }
    );
  }
}
